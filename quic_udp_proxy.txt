/**
 * @file quic_udp_proxy.hpp
 * @brief –ö—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è –∑–∞–≥–æ–ª–æ–≤–æ—á–Ω–æ–≥–æ —Ñ–∞–π–ª–∞.
 *
 * –ë–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ —Ç–æ–≥–æ, –∫–∞–∫–∏–µ –∫–ª–∞—Å—Å—ã, —Ñ—É–Ω–∫—Ü–∏–∏, —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –æ–±—ä—è–≤–ª—è–µ—Ç —Ñ–∞–π–ª.
 * –ú–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –¥—Ä—É–≥–∏—Ö –º–æ–¥—É–ª–µ–π –∏–ª–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è.
 *
 * @author Telian Edward <telianedward@icloud.com>
 * @assisted-by AI-Assistant
 * @date 2025-09-29
 * @version 1.0
 * @license MIT
 *
 * @note –≠—Ç–æ—Ç —Ñ–∞–π–ª —Ç—Ä–µ–±—É–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞ C++23 (ISO/IEC 14882:2024).
 * –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è: std::vector, std::unordered_map, std::random_device, std::mt19937.
 *
 * @note –í–Ω–µ—à–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:
 * - –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ C++23.
 * - –°–∏—Å—Ç–µ–º–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏: <sys/socket.h>, <netinet/in.h>, <unistd.h>.
 * - –ù–µ —Ç—Ä–µ–±—É–µ—Ç —Å—Ç–æ—Ä–æ–Ω–Ω–∏—Ö –±–∏–±–ª–∏–æ—Ç–µ–∫.
 */

#pragma once

#include <iostream>
#include <cstring>
#include <unordered_map>
#include <vector>
#include <string>
#include <cstdint>   // –î–ª—è uint8_t, uint16_t, uint32_t
#include <algorithm> // –î–ª—è std::min, std::max
#include <cstdlib>   // –î–ª—è std::srand, std::rand
#include "server/logger.h"

/**
 * @brief –•–µ—à-—Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è std::vector<uint8_t>
 *
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è CID –≤ session_map.
 */
struct VectorHash
{
    size_t operator()(const std::vector<uint8_t> &v) const noexcept;
};

/**
 * @brief –û–ø–µ—Ä–∞—Ç–æ—Ä —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –¥–ª—è –≤–µ–∫—Ç–æ—Ä–æ–≤ –±–∞–π—Ç–æ–≤
 *
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è CID –≤ reverse_map.
 */
struct VectorEqual
{
    bool operator()(const std::vector<uint8_t> &a, const std::vector<uint8_t> &b) const noexcept;
};


/**
 * @brief –ö–ª—é—á –∫–ª–∏–µ–Ω—Ç–∞: IP, –ø–æ—Ä—Ç –∏ –ø–µ—Ä–≤—ã–µ 8 –±–∞–π—Ç SCID
 *
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –º–∞–ø–ø–∏–Ω–≥–∞ —Å–µ—Å—Å–∏–π –º–µ–∂–¥—É –∫–ª–∏–µ–Ω—Ç–æ–º –∏ –ª–æ–∫–∞–ª—å–Ω—ã–º CID.
 */
struct ClientKey
{
    uint32_t addr;          ///< IPv4-–∞–¥—Ä–µ—Å –∫–ª–∏–µ–Ω—Ç–∞
    uint16_t port;          ///< –ü–æ—Ä—Ç –∫–ª–∏–µ–Ω—Ç–∞
    uint8_t cid[8];         ///< –ü–µ—Ä–≤—ã–µ 8 –±–∞–π—Ç –∏—Å—Ö–æ–¥–Ω–æ–≥–æ SCID
    std::vector<uint8_t> token; ///< –¢–æ–∫–µ–Ω –∏–∑ Retry-–ø–∞–∫–µ—Ç–∞
    bool operator==(const ClientKey &other) const noexcept;
};

/**
 * @brief –•–µ—à –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã ClientKey
 *
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è –∫–ª—é—á–µ–π –≤ session_map.
 */
struct ClientKeyHash
{
    size_t operator()(const ClientKey &k) const noexcept;
};

// === –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã ===
constexpr char BACKEND_IP[] = "10.8.0.11";   ///< IP —Å–µ—Ä–≤–µ—Ä–∞ –≤ –†–§ —á–µ—Ä–µ–∑ WireGuard
constexpr int BACKEND_PORT = 8585;           ///< –ü–æ—Ä—Ç H3-—Å–µ—Ä–≤–µ—Ä–∞ –≤ –†–§
constexpr int LISTEN_PORT = 443;             ///< –ü–æ—Ä—Ç, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º —Å–ª—É—à–∞–µ—Ç –ø—Ä–æ–∫—Å–∏ (HTTPS)
constexpr size_t MAX_PACKET_SIZE = 1500;     ///< –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä UDP-–ø–∞–∫–µ—Ç–∞

static_assert(MAX_PACKET_SIZE <= 65536, "MAX_PACKET_SIZE –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å <= 65536");

// === –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ ===

/**
 * @brief –ú–∞–ø–ø–∏–Ω–≥ –∫–ª—é—á–∞ –∫–ª–∏–µ–Ω—Ç–∞ ‚Üí –ª–æ–∫–∞–ª—å–Ω—ã–π CID.
 *
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ SCID –ø—Ä–∏ –æ—Ç–≤–µ—Ç–µ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞.
 */
extern std::unordered_map<ClientKey, ClientKey, ClientKeyHash> session_map;

/**
 * @brief –û–±—Ä–∞—Ç–Ω—ã–π –º–∞–ø–ø–∏–Ω–≥: –ª–æ–∫–∞–ª—å–Ω—ã–π CID ‚Üí –∫–ª—é—á –∫–ª–∏–µ–Ω—Ç–∞.
 *
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ø–æ–∏—Å–∫–∞ –∫–ª–∏–µ–Ω—Ç–∞ –ø–æ CID –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –æ—Ç–≤–µ—Ç–∞ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞.
 */
extern std::unordered_map<std::vector<uint8_t>, ClientKey, VectorHash, VectorEqual> reverse_map;

// === –§—É–Ω–∫—Ü–∏–∏ ===

/**
 * @brief –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –Ω–µ–±–ª–æ–∫–∏—Ä—É—é—â–∏–π —Ä–µ–∂–∏–º —Å–æ–∫–µ—Ç–∞
 * @param fd –î–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä —Å–æ–∫–µ—Ç–∞
 * @return 0 –ø—Ä–∏ —É—Å–ø–µ—Ö–µ, -1 –ø—Ä–∏ –æ—à–∏–±–∫–µ
 * @throws –ù–∏–∫–∞–∫–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π ‚Äî —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç.
 */
[[nodiscard]] int set_nonblocking(int fd) noexcept;

/**
 * @brief –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–π 8-–±–∞–π—Ç–æ–≤—ã–π CID
 * @return –í–µ–∫—Ç–æ—Ä –∏–∑ 8 —Å–ª—É—á–∞–π–Ω—ã—Ö –±–∞–π—Ç
 * @throws –ù–∏–∫–∞–∫–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π ‚Äî —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç.
 */
[[nodiscard]] std::vector<uint8_t> generate_local_cid() noexcept;

/**
 * @brief –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –≤–Ω–µ—à–Ω–∏–π IP-–∞–¥—Ä–µ—Å —Å–∏—Å—Ç–µ–º—ã —á–µ—Ä–µ–∑ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ 8.8.8.8:53
 * @param ip_out –°—Ç—Ä–æ–∫–∞ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è IP
 * @return true, –µ—Å–ª–∏ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å
 * @throws –ù–∏–∫–∞–∫–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π ‚Äî —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç.
 * @warning –ú–æ–∂–µ—Ç –≤–µ—Ä–Ω—É—Ç—å –Ω–µ–≤–µ—Ä–Ω—ã–π IP –ø—Ä–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞—Ö
 */
[[nodiscard]] bool get_external_ip(std::string &ip_out) noexcept;

/**
 * @brief –í—ã–≤–æ–¥–∏—Ç –±–∞–π—Ç—ã –≤ hex-—Ñ–æ—Ä–º–∞—Ç–µ (–ø–µ—Ä–≤—ã–µ 32 –±–∞–π—Ç–∞)
 * @param data –£–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –¥–∞–Ω–Ω—ã–µ
 * @param len –î–ª–∏–Ω–∞ –¥–∞–Ω–Ω—ã—Ö
 * @param label –ú–µ—Ç–∫–∞ –¥–ª—è –≤—ã–≤–æ–¥–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "HEADER")
 * @throws –ù–∏–∫–∞–∫–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π ‚Äî —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç.
 */
void print_hex(const uint8_t *data, size_t len, const std::string &label) noexcept;

/**
 * @brief –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è (SIGINT, SIGTERM)
 * @param sig –ù–æ–º–µ—Ä —Å–∏–≥–Ω–∞–ª–∞
 * @throws –ù–∏–∫–∞–∫–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π ‚Äî —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç.
 */
void signal_handler(int sig);
/**
 * @file quic_udp_proxy.cpp
 * @brief –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç–æ–¥–æ–≤, –æ–±—ä—è–≤–ª–µ–Ω–Ω—ã—Ö –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–º .h —Ñ–∞–π–ª–µ.
 *
 * –ó–¥–µ—Å—å —Ä–µ–∞–ª–∏–∑—É—é—Ç—Å—è –º–µ—Ç–æ–¥—ã, —É—Ç–∏–ª–∏—Ç–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏, –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞.
 * –§–∞–π–ª —Ä–∞–±–æ—Ç–∞–µ—Ç —Å PostgreSQL —á–µ—Ä–µ–∑ libpqxx –∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞–º C++23.
 *
 * @author Telian Edward <telianedward@icloud.com>
 * @assisted-by AI-Assistant
 * @date 2025-09-29
 * @version 1.0
 * @license MIT
 */

#include "quic_udp_proxy.hpp"
#include "server/logger.h"
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <fcntl.h>
#include <arpa/inet.h>
#include <csignal>
#include <cerrno>
#include <sys/select.h>
#include <cstdio>
#include <ctime>  // –î–ª—è std::time(nullptr)
#include <random> // –î–ª—è std::mt19937, std::uniform_int_distribution

// === –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö ===

// –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: session_map —Ç–µ–ø–µ—Ä—å —Ö—Ä–∞–Ω–∏—Ç ClientKey ‚Üí ClientKey
std::unordered_map<ClientKey, ClientKey, ClientKeyHash> session_map;
std::unordered_map<std::vector<uint8_t>, ClientKey, VectorHash, VectorEqual> reverse_map;

// === –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏–π ===

size_t VectorHash::operator()(const std::vector<uint8_t> &v) const noexcept
{
    std::hash<uint64_t> hasher;
    size_t result = 0;
    for (size_t i = 0; i < v.size(); ++i)
    {
        result ^= hasher(v[i]) + 2654435761U + (result << 6) + (result >> 2);
    }
    return result;
}

bool VectorEqual::operator()(const std::vector<uint8_t> &a, const std::vector<uint8_t> &b) const noexcept
{
    return a == b;
}

bool ClientKey::operator==(const ClientKey &other) const noexcept
{
    return addr == other.addr && port == other.port &&
           std::memcmp(cid, other.cid, 8) == 0 &&
           token == other.token;
}

size_t ClientKeyHash::operator()(const ClientKey &k) const noexcept
{
    size_t result = std::hash<uint32_t>()(k.addr) ^
                   (std::hash<uint16_t>()(k.port) << 1) ^
                   std::hash<uint64_t>()(*reinterpret_cast<const uint64_t *>(k.cid));
    // –•–µ—à–∏—Ä—É–µ–º —Ç–æ–∫–µ–Ω
    for (uint8_t b : k.token)
    {
        result ^= std::hash<uint8_t>()(b) + 2654435761U + (result << 6) + (result >> 2);
    }
    return result;
}

int set_nonblocking(int fd) noexcept
{
    int flags = fcntl(fd, F_GETFL, 0);
    if (flags == -1)
        return -1;
    return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
}

std::vector<uint8_t> generate_local_cid() noexcept
{
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º std::mt19937 –¥–ª—è C++23
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 255);

    std::vector<uint8_t> cid(8);
    for (int i = 0; i < 8; ++i)
    {
        cid[i] = static_cast<uint8_t>(dis(gen)); // —É–Ω–∏–∫–∞–ª—å–Ω—ã–π SCID
    }
    return cid;
}

bool get_external_ip(std::string &ip_out) noexcept
{
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0)
        return false;

    struct sockaddr_in temp_addr{};
    temp_addr.sin_family = AF_INET;
    temp_addr.sin_port = htons(53);
    inet_pton(AF_INET, "8.8.8.8", &temp_addr.sin_addr);

    if (::connect(sock, (struct sockaddr *)&temp_addr, sizeof(temp_addr)) < 0)
    {
        ::close(sock);
        return false;
    }

    socklen_t len = sizeof(temp_addr);
    if (getsockname(sock, (struct sockaddr *)&temp_addr, &len) < 0)
    {
        ::close(sock);
        return false;
    }

    ip_out = inet_ntoa(temp_addr.sin_addr);
    ::close(sock);
    return true;
}

void print_hex(const uint8_t *data, size_t len, const std::string &label) noexcept
{
    if (!data || len == 0)
    {
        std::printf("[DEBUG] [%s:%d] %s: –ø—É—Å—Ç—ã–µ –¥–∞–Ω–Ω—ã–µ\n", __FILE__, __LINE__, label.c_str());
        return;
    }

    std::printf("[DEBUG] [%s:%d] %s: ", __FILE__, __LINE__, label.c_str());
    for (size_t i = 0; i < std::min(len, 32UL); ++i)
    {
        std::printf("%02x ", data[i]);
    }
    if (len > 32)
        std::printf("...");
    std::printf("\n");
}

volatile sig_atomic_t running = true;

void signal_handler(int sig)
{
    std::printf("[INFO] [quic_udp_proxy.cpp:%d] –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª %d. –û—Å—Ç–∞–Ω–æ–≤–∫–∞...\n", __LINE__, sig);
    running = false;
}

// === –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª ===

int main()
{
    int udp_fd = -1, wg_fd = -1;
    struct sockaddr_in client_addr{}, backend_addr{}, listen_addr{};
    socklen_t client_len = sizeof(client_addr);
    socklen_t backend_len = sizeof(backend_addr);

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª
    std::random_device rd;
    std::mt19937 gen(rd());

    // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤
    std::signal(SIGINT, signal_handler);
    std::signal(SIGTERM, signal_handler);

    // --- –°–æ–∑–¥–∞–Ω–∏–µ —Å–æ–∫–µ—Ç–∞ –¥–ª—è –∫–ª–∏–µ–Ω—Ç–æ–≤ (–ø–æ—Ä—Ç 443) ---
    udp_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (udp_fd < 0)
    {
        std::perror("[ERROR] socket udp_fd failed");
        return 1;
    }

    int opt = 1;
    if (setsockopt(udp_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0)
    {
        std::perror("[ERROR] setsockopt SO_REUSEADDR failed");
    }
    if (setsockopt(udp_fd, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt)) < 0)
    {
        std::perror("[ERROR] setsockopt SO_REUSEPORT failed");
    }

    if (set_nonblocking(udp_fd) == -1)
    {
        std::perror("[ERROR] set_nonblocking udp_fd failed");
        ::close(udp_fd);
        return 1;
    }

    // --- –ü—Ä–∏–≤—è–∑–∫–∞ –∫ –ø–æ—Ä—Ç—É ---
    memset(&listen_addr, 0, sizeof(listen_addr));
    listen_addr.sin_family = AF_INET;
    listen_addr.sin_addr.s_addr = INADDR_ANY;
    listen_addr.sin_port = htons(LISTEN_PORT);

    if (bind(udp_fd, (struct sockaddr *)&listen_addr, sizeof(listen_addr)) < 0)
    {
        std::perror("[ERROR] bind udp_fd failed");
        ::close(udp_fd);
        return 1;
    }

    // --- –°–æ–∑–¥–∞–Ω–∏–µ —Å–æ–∫–µ—Ç–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ –†–§ ---
    wg_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (wg_fd < 0)
    {
        std::perror("[ERROR] socket wg_fd failed");
        ::close(udp_fd);
        return 1;
    }

    if (set_nonblocking(wg_fd) == -1)
    {
        std::perror("[ERROR] set_nonblocking wg_fd failed");
        ::close(udp_fd);
        ::close(wg_fd);
        return 1;
    }

    memset(&backend_addr, 0, sizeof(backend_addr));
    backend_addr.sin_family = AF_INET;
    inet_pton(AF_INET, BACKEND_IP, &backend_addr.sin_addr);
    backend_addr.sin_port = htons(BACKEND_PORT);

    std::printf("[INFO] [quic_udp_proxy.cpp:%d] –ó–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É %d, —Å–ª—É—à–∞–µ—Ç 0.0.0.0, –±—ç–∫–µ–Ω–¥: %s:%d\n",
                __LINE__, LISTEN_PORT, BACKEND_IP, BACKEND_PORT);

    char buf[MAX_PACKET_SIZE];
    fd_set read_fds;

    while (running)
    {
        FD_ZERO(&read_fds);
        FD_SET(udp_fd, &read_fds);
        FD_SET(wg_fd, &read_fds);
        int max_fd = std::max(udp_fd, wg_fd);

        timeval timeout{.tv_sec = 0, .tv_usec = 100000};
        int activity = select(max_fd + 1, &read_fds, nullptr, nullptr, &timeout);
        if (activity < 0 && errno != EINTR)
        {
            std::fprintf(stderr, "[ERROR] [quic_udp_proxy.cpp:%d] select error: %s\n", __LINE__, strerror(errno));
            continue;
        }

        // === –ù–ê–ü–†–ê–í–õ–ï–ù–ò–ï: –ö–õ–ò–ï–ù–¢ ‚Üí –°–ï–†–í–ï–† ===
        if (FD_ISSET(udp_fd, &read_fds))
        {
            ssize_t n = recvfrom(udp_fd, buf, sizeof(buf), 0,
                                 (struct sockaddr *)&client_addr, &client_len);

         if (n < 0 || static_cast<size_t>(n) >= MAX_PACKET_SIZE)
            {
                if (errno != EAGAIN && errno != EWOULDBLOCK)
                    std::fprintf(stderr, "[ERROR] [quic_udp_proxy.cpp:%d] recvfrom client failed: %s\n", __LINE__, strerror(errno));
                continue;
            }

            std::string client_ip = inet_ntoa(client_addr.sin_addr);
            uint16_t client_port = ntohs(client_addr.sin_port);

            std::printf("\n=== [CLIENT ‚Üí SERVER] ===\n");
            std::printf("[INFO] [quic_udp_proxy.cpp:%d] –ü–æ–ª—É—á–µ–Ω–æ %zd –±–∞–π—Ç –æ—Ç %s:%u\n", __LINE__, n, client_ip.c_str(), client_port);
            print_hex(reinterpret_cast<uint8_t *>(buf), static_cast<size_t>(n), "HEADER");

            if (n < 6)
            {
                std::printf("[WARNING] [quic_udp_proxy.cpp:%d] –°–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π –ø–∞–∫–µ—Ç (%zd –±–∞–π—Ç)\n", __LINE__, n);
                continue;
            }

            uint8_t packet_type = buf[0];
            if ((packet_type & 0xC0) != 0xC0)
            {
                std::printf("[DEBUG] [quic_udp_proxy.cpp:%d] Short Header ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º\n", __LINE__);
                continue;
            }

            // === –û–±—Ä–∞–±–æ—Ç–∫–∞ Retry-–ø–∞–∫–µ—Ç–∞ ===
            if (n >= 9 && static_cast<unsigned char>(buf[0]) == 0xF0)
            {
                // –≠—Ç–æ Retry-–ø–∞–∫–µ—Ç
                LOG_INFO("Received Retry packet");
                // –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–æ–∫–µ–Ω –∏–∑ Retry-–ø–∞–∫–µ—Ç–∞
                size_t token_offset = 9;
                size_t token_len = buf[token_offset];
                std::vector<uint8_t> token(buf + token_offset + 1, buf + token_offset + 1 + token_len);
                // –°–æ–∑–¥–∞—ë–º –∫–ª—é—á –Ω–∞ –æ—Å–Ω–æ–≤–µ IP –∏ –ø–æ—Ä—Ç–∞ –∫–ª–∏–µ–Ω—Ç–∞
                ClientKey key{};
                key.addr = client_addr.sin_addr.s_addr;
                key.port = client_addr.sin_port;
                // –ü–µ—Ä–≤—ã–µ 8 –±–∞–π—Ç –ø–æ—Å–ª–µ —Ç–æ–∫–µ–Ω–∞ ‚Äî —ç—Ç–æ SCID (–∏—Å–ø–æ–ª—å–∑—É–µ–º –∏—Ö –∫–∞–∫ CID)
                std::memset(key.cid, 0, 8);
                std::memcpy(key.cid, buf + 9, 8); // –ü–µ—Ä–≤—ã–µ 8 –±–∞–π—Ç –ø–æ—Å–ª–µ —Ç–æ–∫–µ–Ω–∞ ‚Äî —ç—Ç–æ SCID
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–∫–µ–Ω –≤ session_map
                key.token = token;
                session_map[key] = key; // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤–µ—Å—å –æ–±—ä–µ–∫—Ç ClientKey
                // –ü–µ—Ä–µ—Å—ã–ª–∞–µ–º Retry-–ø–∞–∫–µ—Ç –∫–ª–∏–µ–Ω—Ç—É
                ssize_t sent = sendto(udp_fd, buf, n, 0,
                                      (struct sockaddr *)&client_addr, sizeof(client_addr));
                if (sent < 0) {
                    LOG_ERROR("sendto client failed: {}", strerror(errno));
                } else {
                    LOG_INFO("Retry packet sent to client");
                }
                continue; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–∞–ª—å–Ω–µ–π—à—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É —ç—Ç–æ–≥–æ –ø–∞–∫–µ—Ç–∞
            }

            uint32_t version = (buf[1] << 24) | (buf[2] << 16) | (buf[3] << 8) | buf[4];
            size_t pos = 5;
            uint8_t dcil = buf[pos];
            uint8_t scil = buf[pos + 1];

            std::printf("[INFO] [quic_udp_proxy.cpp:%d] QUIC –í–µ—Ä—Å–∏—è: 0x%08x, DCIL=%d, SCIL=%d\n",
                        __LINE__, version, dcil, scil);

            if (dcil == 0 || scil == 0 || pos + 2 + dcil + scil > static_cast<size_t>(n))
            {
                std::printf("[WARNING] [quic_udp_proxy.cpp:%d] –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ CID –¥–ª–∏–Ω—ã\n", __LINE__);
                continue;
            }

            // uint8_t *dcid = reinterpret_cast<uint8_t *>(&buf[pos + 2]);

            uint8_t *scid = reinterpret_cast<uint8_t *>(&buf[pos + 2 + dcil]);

            ClientKey key{};
            key.addr = client_addr.sin_addr.s_addr;
            key.port = client_addr.sin_port;
            std::memset(key.cid, 0, 8);
            std::memcpy(key.cid, scid, std::min(static_cast<size_t>(scil), 8UL));

            auto it = session_map.find(key);
            std::vector<uint8_t> local_cid;
            if (it == session_map.end())
            {
                local_cid = generate_local_cid();
                session_map[key] = key; // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤–µ—Å—å –æ–±—ä–µ–∫—Ç ClientKey
                reverse_map[local_cid] = key;
                std::printf("[INFO] [quic_udp_proxy.cpp:%d] –ù–æ–≤–∞—è —Å–µ—Å—Å–∏—è: %s:%u ‚Üí LocalCID:", __LINE__, client_ip.c_str(), client_port);
                for (uint8_t b : local_cid)
                    printf("%02x", b);
                std::printf("\n");
            }
            else
            {
                local_cid.assign(it->second.cid, it->second.cid + 8);// –ò—Å–ø–æ–ª—å–∑—É–µ–º CID –∏–∑ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–≥–æ –∫–ª—é—á–∞
                std::printf("[DEBUG] [quic_udp_proxy.cpp:%d] Reuse LocalCID:", __LINE__);
                for (uint8_t b : local_cid)
                    printf("%02x", b);
                std::printf("\n");
            }

            // === –ú–û–î–ò–§–ò–ö–ê–¶–ò–Ø –ü–ê–ö–ï–¢–ê: SCIL = 8, SCID = LocalCID ===
            if (scil > 20)
            {
                std::printf("[WARNING] [quic_udp_proxy.cpp:%d] –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π SCIL=%d, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º SCIL=8\n", __LINE__, scil);
                scil = 8;
            }
            buf[5] = (buf[5] & 0xF0) | 8;           // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º SCIL = 8
            std::memcpy(scid, local_cid.data(), 8);   // –ó–∞–º–µ–Ω—è–µ–º SCID –Ω–∞ LocalCID
            // –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–∫–µ–Ω –≤ –ø–∞–∫–µ—Ç
            if (it != session_map.end() && it->second.token.size() > 0)
            {
                // –í—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–∫–µ–Ω –≤ –ø–∞–∫–µ—Ç
                size_t token_offset = 9;
                buf[token_offset] = it->second.token.size();
                std::memcpy(buf + token_offset + 1, it->second.token.data(), it->second.token.size());
            }

            ssize_t sent = sendto(wg_fd, buf, n, 0,
                                  (struct sockaddr *)&backend_addr, sizeof(backend_addr));
            if (sent < 0)
            {
                std::fprintf(stderr, "[ERROR] [quic_udp_proxy.cpp:%d] sendto backend failed: %s\n", __LINE__, strerror(errno));
            }
            else
            {
                std::printf("[INFO] [quic_udp_proxy.cpp:%d] –ü–µ—Ä–µ—Å–ª–∞–Ω–æ %zd –±–∞–π—Ç –≤ –†–§\n", __LINE__, sent);
            }
        }

        // === –ù–ê–ü–†–ê–í–õ–ï–ù–ò–ï: –°–ï–†–í–ï–† ‚Üí –ö–õ–ò–ï–ù–¢ ===
        if (FD_ISSET(wg_fd, &read_fds))
        {
            ssize_t n = recvfrom(wg_fd, buf, sizeof(buf), 0,
                                 (struct sockaddr *)&backend_addr, &backend_len);

            if (n < 0 || static_cast<size_t>(n) >= MAX_PACKET_SIZE)
            {
                if (errno != EAGAIN && errno != EWOULDBLOCK)
                    std::fprintf(stderr, "[ERROR] [quic_udp_proxy.cpp:%d] recvfrom backend failed: %s\n", __LINE__, strerror(errno));
                continue;
            }

            std::printf("\n=== [SERVER ‚Üí CLIENT] ===\n");
            std::printf("[INFO] [quic_udp_proxy.cpp:%d] –ü–æ–ª—É—á–µ–Ω–æ %zd –±–∞–π—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞\n", __LINE__, n);
            print_hex(reinterpret_cast<uint8_t *>(buf), static_cast<size_t>(n), "REPLY_HEADER");

            if (n < 6)
            {
                std::printf("[WARNING] [quic_udp_proxy.cpp:%d] –°–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π –ø–∞–∫–µ—Ç (%zd –±–∞–π—Ç)\n", __LINE__, n);
                continue;
            }

            uint8_t packet_type = buf[0];
            // === –û–±—Ä–∞–±–æ—Ç–∫–∞ Retry-–ø–∞–∫–µ—Ç–∞ ===
            if ((packet_type & 0xC0) == 0xC0)
            { // –≠—Ç–æ Long Header
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–∞–∫–µ—Ç Retry
                if (buf[5] == 0x00 && buf[6] == 0x00 && buf[7] == 0x00 && buf[8] == 0x00)
                {
                    // –≠—Ç–æ Retry-–ø–∞–∫–µ—Ç
                    LOG_INFO("Received Retry packet");
                    // –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–æ–∫–µ–Ω –∏–∑ Retry-–ø–∞–∫–µ—Ç–∞
                    size_t token_offset = 9;
                    size_t token_len = buf[token_offset];
                    std::vector<uint8_t> token(buf + token_offset + 1, buf + token_offset + 1 + token_len);
                    // –°–æ–∑–¥–∞—ë–º –∫–ª—é—á –Ω–∞ –æ—Å–Ω–æ–≤–µ IP –∏ –ø–æ—Ä—Ç–∞ –∫–ª–∏–µ–Ω—Ç–∞ (–∏–∑ client_addr)
                    ClientKey key{};
                    key.addr = client_addr.sin_addr.s_addr;
                    key.port = client_addr.sin_port;
                    // –ü–µ—Ä–≤—ã–µ 8 –±–∞–π—Ç –ø–æ—Å–ª–µ —Ç–æ–∫–µ–Ω–∞ ‚Äî —ç—Ç–æ SCID (–∏—Å–ø–æ–ª—å–∑—É–µ–º –∏—Ö –∫–∞–∫ CID)
                    std::memset(key.cid, 0, 8);
                    std::memcpy(key.cid, buf + 9, 8); // –ü–µ—Ä–≤—ã–µ 8 –±–∞–π—Ç –ø–æ—Å–ª–µ —Ç–æ–∫–µ–Ω–∞ ‚Äî —ç—Ç–æ SCID
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–∫–µ–Ω –≤ session_map
                    key.token = token;
                    session_map[key] = key; // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤–µ—Å—å –æ–±—ä–µ–∫—Ç ClientKey
                    // –ü–µ—Ä–µ—Å—ã–ª–∞–µ–º Retry-–ø–∞–∫–µ—Ç –∫–ª–∏–µ–Ω—Ç—É
                    ssize_t sent = sendto(udp_fd, buf, n, 0,
                                          (struct sockaddr *)&client_addr, sizeof(client_addr));
                    if (sent < 0)
                    {
                        LOG_ERROR("sendto client failed: {}", strerror(errno));
                    }
                    else
                    {
                        LOG_INFO("Retry packet sent to client");
                    }
                    continue; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–∞–ª—å–Ω–µ–π—à—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É —ç—Ç–æ–≥–æ –ø–∞–∫–µ—Ç–∞
                }
            }
            // === –ö–æ–Ω–µ—Ü –æ–±—Ä–∞–±–æ—Ç–∫–∏ Retry-–ø–∞–∫–µ—Ç–∞ ===

            if ((packet_type & 0xC0) != 0xC0)
            {
                std::printf("[DEBUG] [quic_udp_proxy.cpp:%d] Short Header ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º\n", __LINE__);
                continue;
            }

            size_t pos = 5;
            uint8_t dcil = buf[pos];
            uint8_t scil = buf[pos + 1];

            if (dcil == 0 || scil == 0 || pos + 2 + dcil + scil > static_cast<size_t>(n))
            {
                std::printf("[WARNING] [quic_udp_proxy.cpp:%d] –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ CID\n", __LINE__);
                continue;
            }

            uint8_t *dcid = reinterpret_cast<uint8_t *>(&buf[pos + 2]);
            std::vector<uint8_t> local_cid_vec(dcid, dcid + 8);

            auto rev_it = reverse_map.find(local_cid_vec);
            if (rev_it == reverse_map.end())
            {
                std::printf("[WARNING] [quic_udp_proxy.cpp:%d] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π LocalCID ‚Äî –ø–∞–∫–µ—Ç –ø–æ—Ç–µ—Ä—è–ª—Å—è\n", __LINE__);
                continue;
            }

            ClientKey orig_key = rev_it->second;

            // === –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ò–ï –û–†–ò–ì–ò–ù–ê–õ–¨–ù–û–ì–û SCID –ö–ê–ö DCID ===
            buf[5] = (8 << 4) | (buf[5] & 0x0F); // DCIL = 8
            std::memcpy(dcid, orig_key.cid, 8);

            struct sockaddr_in client_dest{};
            client_dest.sin_family = AF_INET;
            client_dest.sin_addr.s_addr = orig_key.addr;
            client_dest.sin_port = orig_key.port;

            ssize_t sent = sendto(udp_fd, buf, n, 0,
                                  (struct sockaddr *)&client_dest, sizeof(client_dest));

            if (sent < 0)
            {
                std::fprintf(stderr, "[ERROR] [quic_udp_proxy.cpp:%d] sendto client failed: %s\n", __LINE__, strerror(errno));
            }
            else
            {
                std::printf("[INFO] [quic_udp_proxy.cpp:%d] –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ %zd –±–∞–π—Ç –∫–ª–∏–µ–Ω—Ç—É %s:%u\n",
                            __LINE__, sent, inet_ntoa(client_dest.sin_addr), ntohs(client_dest.sin_port));
            }
        }
    }

    std::printf("[INFO] [quic_udp_proxy.cpp:%d] –ü—Ä–æ–∫—Å–∏ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.\n", __LINE__);
    if (udp_fd != -1)
        ::close(udp_fd);
    if (wg_fd != -1)
        ::close(wg_fd);
    return 0;
}
/**
 * @file logger.hpp
 * @brief –õ–æ–≥–≥–µ—Ä –¥–ª—è –ø—Ä–æ–µ–∫—Ç–∞ –Ω–∞ C++20/23 —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —Ü–≤–µ—Ç–æ–≤ –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∑–∞—Ö–≤–∞—Ç–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞.
 *
 * –ü—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —É–¥–æ–±–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å —É—Ä–æ–≤–Ω—è–º–∏ (DEBUG, INFO, WARN, ERROR, SUCCESS),
 * –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º —Ñ–∞–π–ª–∞, —Å—Ç—Ä–æ–∫–∏, —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –≤—Ä–µ–º–µ–Ω–Ω–æ–π –º–µ—Ç–∫–∏.
 * –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ü–≤–µ—Ç–Ω–æ–π –≤—ã–≤–æ–¥ –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª–µ (ANSI escape codes) –∏ —ç–º–æ–¥–∑–∏ –¥–ª—è –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–ª–∏—á–µ–Ω–∏—è —É—Ä–æ–≤–Ω–µ–π.
 * –¢–∞–∫–∂–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç LOG_RAW –¥–ª—è –ø—Ä—è–º–æ–≥–æ –≤—ã–≤–æ–¥–∞ –±–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è –≤–Ω–µ—à–Ω–∏—Ö –±–∏–±–ª–∏–æ—Ç–µ–∫).
 *
 * @author Telian Edward <telianedward@icloud.com>
 * @assisted-by AI-Assistant
 * @date 2025-09-29
 * @version 1.0
 * @license MIT
 */

#pragma once

#include <string>
#include <source_location>
#include <chrono>
#include <iostream>
#include <iomanip>
#include <mutex>

#ifdef _WIN32
    #include <io.h>
    #include <fcntl.h>
#else
    #include <unistd.h>
#endif

// –î–ª—è fmt::format
#include <fmt/core.h>

/**
 * @brief –£—Ä–æ–≤–Ω–∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.
 */
enum class LogLevel {
    DEBUG,   ///< –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è (–Ω–∏–∑–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
    INFO,    ///< –û–±—â–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –∑–∞–ø–∏—Å—å
    WARN,    ///< –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ (–≤–æ–∑–º–æ–∂–Ω–∞—è –ø—Ä–æ–±–ª–µ–º–∞)
    ERROR,   ///< –û—à–∏–±–∫–∞ (–Ω–∞—Ä—É—à–µ–Ω–∏–µ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞)
    SUCCESS  ///< –£—Å–ø–µ—à–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ (–≤–∏–∑—É–∞–ª—å–Ω–æ –≤—ã–¥–µ–ª—è–µ—Ç—Å—è)
};

/**
 * @brief –í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –∏–º—ë–Ω –¥–ª—è –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π –ª–æ–≥–≥–µ—Ä–∞.
 *
 * –í—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–º–µ—é—Ç –≤–Ω—É—Ç—Ä–µ–Ω–Ω—é—é –ª–∏–Ω–∫–æ–≤–∫—É (static linkage) –±–ª–∞–≥–æ–¥–∞—Ä—è –∞–Ω–æ–Ω–∏–º–Ω–æ–º—É namespace.
 */
namespace {

/**
 * @brief –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç ANSI-–∫–æ–¥ —Ü–≤–µ—Ç–∞ –¥–ª—è –∑–∞–¥–∞–Ω–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.
 * @param level –£—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.
 * @return –£–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —Å—Ç—Ä–æ–∫—É —Å ANSI-–∫–æ–¥–æ–º —Ü–≤–µ—Ç–∞.
 */
const char* get_color_code(LogLevel level) {
    switch (level) {
        case LogLevel::DEBUG:   return "\033[36m"; // Cyan
        case LogLevel::INFO:    return "\033[34m"; // Blue
        case LogLevel::WARN:    return "\033[33m"; // Yellow
        case LogLevel::ERROR:   return "\033[31m"; // Red
        case LogLevel::SUCCESS: return "\033[32m"; // Green
        default:                return "\033[0m";
    }
}

/**
 * @brief –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —ç–º–æ–¥–∑–∏, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —É—Ä–æ–≤–Ω—é –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.
 * @param level –£—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.
 * @return –£–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —Å—Ç—Ä–æ–∫–æ–≤—ã–π –ª–∏—Ç–µ—Ä–∞–ª —Å —ç–º–æ–¥–∑–∏ –≤ –∫–æ–¥–∏—Ä–æ–≤–∫–µ UTF-8.
 * @warning –¢—Ä–µ–±—É–µ—Ç—Å—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞ UTF-8 –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª–µ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.
 */
const char* get_emoji(LogLevel level) {
    switch (level) {
        case LogLevel::DEBUG:   return "üíü";
        case LogLevel::INFO:    return "üîµ";
        case LogLevel::WARN:    return "‚ö†Ô∏è";
        case LogLevel::ERROR:   return "‚ùå";
        case LogLevel::SUCCESS: return "‚úÖ";
        default:                return "";
    }
}

/**
 * @brief ANSI-–∫–æ–¥ –¥–ª—è —Å–±—Ä–æ—Å–∞ —Ü–≤–µ—Ç–∞ —Ç–µ–∫—Å—Ç–∞ –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª–µ.
 */
const char* reset_color = "\033[0m";

/**
 * @brief –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ stdout —Ç–µ—Ä–º–∏–Ω–∞–ª–æ–º.
 * @return true, –µ—Å–ª–∏ stdout –ø–æ–¥–∫–ª—é—á—ë–Ω –∫ TTY.
 */
bool is_stdout_tty() {
#ifdef _WIN32
    return _isatty(_fileno(stdout));
#else
    return isatty(fileno(stdout));
#endif
}

/**
 * @brief –ü–æ–ª—É—á–∞–µ—Ç —Ç–µ–∫—É—â—É—é –≤—Ä–µ–º–µ–Ω–Ω—É—é –º–µ—Ç–∫—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ "–ì–ì–ì–ì-–ú–ú-–î–î –ß–ß:–ú–ú:–°–°".
 * @return –°—Ç—Ä–æ–∫–∞ —Å –≤—Ä–µ–º–µ–Ω–Ω–æ–π –º–µ—Ç–∫–æ–π –≤ –ª–æ–∫–∞–ª—å–Ω–æ–º —á–∞—Å–æ–≤–æ–º –ø–æ—è—Å–µ.
 * @throws std::runtime_error –ü—Ä–∏ –æ—à–∏–±–∫–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏.
 * @warning –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ (localtime_r / localtime_s).
 */
std::string get_timestamp() {
    try {
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);

#ifdef _WIN32
        std::tm local_time;
        if (std::localtime_s(&local_time, &time_t) != 0) {
            throw std::runtime_error("localtime_s failed");
        }
#else
        std::tm local_time;
        if (::localtime_r(&time_t, &local_time) == nullptr) {
            throw std::runtime_error("localtime_r failed");
        }
#endif

        char buffer[20];
        if (std::strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", &local_time) == 0) {
            throw std::runtime_error("strftime failed");
        }
        return std::string(buffer);
    } catch (const std::exception& e) {
        return "TIMESTAMP_ERROR";
    }
}

/**
 * @brief –ú—å—é—Ç–µ–∫—Å –¥–ª—è –ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –ª–æ–≥–≥–µ—Ä–∞.
 *
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤—ã–≤–æ–¥–∞ –≤ cerr.
 * –ú–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç–∫–ª—é—á–µ–Ω, –µ—Å–ª–∏ –ª–æ–≥–≥–µ—Ä –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ –æ–¥–Ω–æ–ø–æ—Ç–æ—á–Ω–æ–º —Ä–µ–∂–∏–º–µ.
 */
std::mutex log_mutex;

} // namespace

/**
 * @brief –û—Å–Ω–æ–≤–Ω–∞—è —à–∞–±–ª–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º.
 *
 * –ù–µ –≤—ã–∑—ã–≤–∞–π—Ç–µ –Ω–∞–ø—Ä—è–º—É—é ‚Äî –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º–∞–∫—Ä–æ—Å—ã LOG_DEBUG, LOG_INFO –∏ —Ç.–¥.
 *
 * @tparam Args –¢–∏–ø—ã –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.
 * @param level –£—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.
 * @param location –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –º–µ—Å—Ç–µ –≤—ã–∑–æ–≤–∞ (–æ–±—ã—á–Ω–æ std::source_location::current()).
 * @param format_str –°—Ç—Ä–æ–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ (—Å–æ–≤–º–µ—Å—Ç–∏–º–∞ —Å fmt::format).
 * @param args –ê—Ä–≥—É–º–µ–Ω—Ç—ã –¥–ª—è –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤ —Å—Ç—Ä–æ–∫—É —Ñ–æ—Ä–º–∞—Ç–∞.
 * @throws –ù–∏–∫–∞–∫–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π ‚Äî —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç.
 */
template<typename... Args>
void log_impl(LogLevel level,
              const std::source_location& location = std::source_location::current(),
              std::string_view format_str = "",
              Args&&... args) {
    const bool use_color = is_stdout_tty();
    const char* color_start = use_color ? get_color_code(level) : "";
    const char* color_reset = use_color ? reset_color : "";

    const char* level_name = [&]() -> const char* {
        switch (level) {
            case LogLevel::DEBUG:   return "DEBUG";
            case LogLevel::INFO:    return "INFO";
            case LogLevel::WARN:    return "WARN";
            case LogLevel::ERROR:   return "ERROR";
            case LogLevel::SUCCESS: return "SUCCESS";
            default:                return "UNKNOWN";
        }
    }();

    // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º fmt::runtime, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–∫–∏ "not a constant expression"
    std::string message = fmt::format(fmt::runtime(format_str), args...);

    // –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –º—å—é—Ç–µ–∫—Å–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –µ—Å–ª–∏ –Ω—É–∂–Ω–∞ –ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å)
    std::lock_guard<std::mutex> lock(log_mutex);

    // –í—ã–≤–æ–¥–∏–º –≤ cerr
    std::cerr << color_start
              << "[" << get_timestamp() << "] "
              << get_emoji(level) << "[" << level_name << "] "
              << "[" << location.file_name() << ":" << location.line() << " in " << location.function_name() << "] "
              << message
              << color_reset
              << std::endl;
}

/**
 * @brief –§—É–Ω–∫—Ü–∏—è –¥–ª—è "—Å—ã—Ä–æ–≥–æ" –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –±–µ–∑ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞.
 *
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å –≤–Ω–µ—à–Ω–∏–º–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞–º–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, quiche),
 * –∫–æ—Ç–æ—Ä—ã–µ –ø–µ—Ä–µ–¥–∞—é—Ç –≥–æ—Ç–æ–≤—ã–µ —Å—Ç—Ä–æ–∫–∏ –ª–æ–≥–æ–≤.
 *
 * @tparam Args –¢–∏–ø—ã –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.
 * @param format_str –°—Ç—Ä–æ–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞.
 * @param args –ê—Ä–≥—É–º–µ–Ω—Ç—ã –¥–ª—è –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∏.
 * @throws –ù–∏–∫–∞–∫–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π ‚Äî —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç.
 */
template<typename... Args>
void log_raw_impl(const std::string& format_str, Args&&... args) {
    // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    std::string message = fmt::format(fmt::runtime(format_str), args...);

    // –í—ã–≤–æ–¥–∏–º –≤ cerr
    std::cerr << message << std::endl;
}

/**
 * @brief –ú–∞–∫—Ä–æ—Å –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —É—Ä–æ–≤–Ω—è DEBUG.
 * @param ... –ê—Ä–≥—É–º–µ–Ω—Ç—ã –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (—Å–æ–≤–º–µ—Å—Ç–∏–º—ã —Å fmt::format).
 * @throws –ù–∏–∫–∞–∫–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π ‚Äî —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç.
 * @warning –ò—Å–ø–æ–ª—å–∑—É–µ—Ç __FILE__, __LINE__, __func__ ‚Äî –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–¥–ª–µ–Ω–Ω—ã–º –≤ release-—Å–±–æ—Ä–∫–µ.
 */
#define LOG_DEBUG(...) log_impl(LogLevel::DEBUG, std::source_location::current(), __VA_ARGS__)

/**
 * @brief –ú–∞–∫—Ä–æ—Å –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —É—Ä–æ–≤–Ω—è INFO.
 * @param ... –ê—Ä–≥—É–º–µ–Ω—Ç—ã –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (—Å–æ–≤–º–µ—Å—Ç–∏–º—ã —Å fmt::format).
 * @throws –ù–∏–∫–∞–∫–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π ‚Äî —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç.
 * @warning –ò—Å–ø–æ–ª—å–∑—É–µ—Ç __FILE__, __LINE__, __func__ ‚Äî –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–¥–ª–µ–Ω–Ω—ã–º –≤ release-—Å–±–æ—Ä–∫–µ.
 */
#define LOG_INFO(...)  log_impl(LogLevel::INFO,  std::source_location::current(), __VA_ARGS__)

/**
 * @brief –ú–∞–∫—Ä–æ—Å –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —É—Ä–æ–≤–Ω—è WARN.
 * @param ... –ê—Ä–≥—É–º–µ–Ω—Ç—ã –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (—Å–æ–≤–º–µ—Å—Ç–∏–º—ã —Å fmt::format).
 * @throws –ù–∏–∫–∞–∫–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π ‚Äî —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç.
 * @warning –ò—Å–ø–æ–ª—å–∑—É–µ—Ç __FILE__, __LINE__, __func__ ‚Äî –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–¥–ª–µ–Ω–Ω—ã–º –≤ release-—Å–±–æ—Ä–∫–µ.
 */
#define LOG_WARN(...)  log_impl(LogLevel::WARN,  std::source_location::current(), __VA_ARGS__)

/**
 * @brief –ú–∞–∫—Ä–æ—Å –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —É—Ä–æ–≤–Ω—è ERROR.
 * @param ... –ê—Ä–≥—É–º–µ–Ω—Ç—ã –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (—Å–æ–≤–º–µ—Å—Ç–∏–º—ã —Å fmt::format).
 * @throws –ù–∏–∫–∞–∫–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π ‚Äî —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç.
 * @warning –ò—Å–ø–æ–ª—å–∑—É–µ—Ç __FILE__, __LINE__, __func__ ‚Äî –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–¥–ª–µ–Ω–Ω—ã–º –≤ release-—Å–±–æ—Ä–∫–µ.
 */
#define LOG_ERROR(...) log_impl(LogLevel::ERROR, std::source_location::current(), __VA_ARGS__)

/**
 * @brief –ú–∞–∫—Ä–æ—Å –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —É—Ä–æ–≤–Ω—è SUCCESS.
 * @param ... –ê—Ä–≥—É–º–µ–Ω—Ç—ã –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (—Å–æ–≤–º–µ—Å—Ç–∏–º—ã —Å fmt::format).
 * @throws –ù–∏–∫–∞–∫–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π ‚Äî —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç.
 * @warning –ò—Å–ø–æ–ª—å–∑—É–µ—Ç __FILE__, __LINE__, __func__ ‚Äî –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–¥–ª–µ–Ω–Ω—ã–º –≤ release-—Å–±–æ—Ä–∫–µ.
 */
#define LOG_SUCCESS(...) log_impl(LogLevel::SUCCESS, std::source_location::current(), __VA_ARGS__)

/**
 * @brief –ú–∞–∫—Ä–æ—Å –¥–ª—è "—Å—ã—Ä–æ–≥–æ" –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –±–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ (–≤—Ä–µ–º—è, —Ñ–∞–π–ª, —Ñ—É–Ω–∫—Ü–∏—è –∏ —Ç.–¥.).
 *
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, –∫–æ–≥–¥–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ —É–∂–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å—é –Ω–µ–æ–±—Ö–æ–¥–∏–º—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
 * –∏–ª–∏ –ø–æ—Å—Ç—É–ø–∞–µ—Ç –∏–∑ –≤–Ω–µ—à–Ω–µ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏.
 *
 * @param ... –ê—Ä–≥—É–º–µ–Ω—Ç—ã –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (—Å–æ–≤–º–µ—Å—Ç–∏–º—ã —Å fmt::format).
 * @throws –ù–∏–∫–∞–∫–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π ‚Äî —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç.
 * @warning –ù–µ –¥–æ–±–∞–≤–ª—è–µ—Ç –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏, —É—Ä–æ–≤–Ω–∏ –∏–ª–∏ —ç–º–æ–¥–∑–∏ ‚Äî —Ç–æ–ª—å–∫–æ —Ç–æ, —á—Ç–æ –ø–µ—Ä–µ–¥–∞–Ω–æ.
 */
#define LOG_RAW(...) log_raw_impl(__VA_ARGS__)